// Written in the D programming language.

// rwg.compiler - compiles rulefiles into executables
// Part of RWG - Random Word Generator
// Copyright (C) 2012 Nathan M. Swan
// Distributed under the Boost Software License
// (See accompanying file ../../LICENSE)

module rwg.compiler;

import std.conv;
import std.exception;
import std.process;
import std.stdio;

import rwg.main;
import rwg.rules;

// compilation consists of:
// 1. creating the source code from rules
// 2. compiling/running it with rdmd
struct Compiler {
    // top structure
    void compile(ref Options opts) {
        readOpts(opts);
        createSource();
        runRdmd(opts.wordcount, opts.seed);
    }
    
    // make sure command-line options make sense
    void readOpts(ref Options opts) {
        shouldRun = !opts.compileOnly;
        ofile = opts.compileOut;
        enforce(shouldRun || ofile !is null,
            "--compile-only requires the setting of --compile-out");
        ifile = opts.rulefile;
        rules = opts.rules;
    }
    
    // greate main function, leave rules to writeRule
    void createSource() {
        srcName = std.path.stripExtension(ifile)~".d";
        src = File(srcName, "w");
        src.writeln(`// auto-generated by rwg 0.2
// DO NOT MODIFY as this will be overridden the next run

import std.algorithm, std.getopt, std.random, std.stdio;

void main(string[] args) {
    uint wc=100, sd=unpredictableSeed;
    getopt(args, "n|count", &wc, "s|seed", &sd);
    auto r=Random(sd);
    foreach(i; 0 .. wc) {
        string wrd;
        do {
            wrd = "";
            tryWord(r, wrd);
        } while (disallowed(wrd));
        writeln(wrd);
    }
}`);
        
        // preliminarily assign rulenums to defined rules
        foreach(name, rule; rules.definedRules) {
            defRulesToNums[name] = rulenum++;
        }
        
        // start writing them
        foreach(name, rule; rules.definedRules) {
            writeRule(rule, defRulesToNums[name]);
        }
        
        // disallow directive
        src.writeln(`bool disallowed(string wrd) {`);
        foreach(dr; rules.seqsToDisallow) {
            src.writefln(`if (wrd.canFind("%s")) { return true; }`, dr);
        }
        src.writeln(`return false;`);
        src.writeln(`}`);
        
        // generate directive
        auto orig = rulenum++;
        writeRule(rules.ruleToGenerate, orig);
        src.writefln(`alias rule%s tryWord;`, orig);
        
        src.close();
    }
    
    // a `rule` is a function which appends random strings into result
    void writeRule(Rule rule, size_t rnum) {
        src.writefln("void rule%s(ref Random r, ref string result) {", rnum);
        // the function just appends, or calls another rule function
        if (rule.peek!(Constant)) {
            auto cons = rule.get!(Constant)();
            if (cons in rules.definedRules) {
                src.writefln("rule%s(r, result);", defRulesToNums[cons]);
            } else {
                src.writefln("result ~= \"%s\";", cons); // TODO sanitize?
            }
            src.writeln("}");
        // calls each child rule function
        } else if (rule.peek!(Sequence)) {
            auto orig = rulenum;
            foreach(rl; rule.get!(Sequence)()) {
                src.writefln("rule%s(r, result);", rulenum++);
            }
            src.writeln("}");
            foreach(rl; rule.get!(Sequence)()) {
                writeRule(rl, orig++);
            }
        // goes down the line, checking if matches
        } else if (rule.peek!(Choice)) {
            src.writeln(`auto f = uniform!"()"(0.0, 1.0, r);`);
            auto orig = rulenum;
            auto choice = rule.get!(Choice);
            foreach(p; choice.percentages[0 .. $-1]) {
                src.writefln(`if (f < %s) { rule%s(r, result); return; }`,
                    p, rulenum++);
            }
            src.writefln(`rule%s(r, result);`, rulenum++);
            src.writeln(`}`);
            foreach(o; choice.options) {
                writeRule(o, orig++);
            }
        } else assert(0);
    }
    
    // run the program externally
    void runRdmd(uint wc, uint seed) {
        // generate args
        string[] args;
        args ~= "rdmd";
        if (!shouldRun) {
            args ~= "--build-only";
        }
        if (ofile !is null) {
            args ~= "-of"~ofile;
        }
        args ~= srcName;
        args ~= "-n"~to!string(wc);
        args ~= "-s"~to!string(seed);
        
        // use the args
        execvp("rdmd", args);
    }
    
    bool shouldRun; // whether to execute the compiled program
    string ifile;   // input rulefile
    string ofile;   // output executable
    Rules rules;    // parsed rules structure
    
    File src;       // intermediat source which rdmd compiles
    string srcName; // filename of src
    
    size_t rulenum = 0; // all rules have numbers, writing a new rule should 
                        // increase that number
    size_t[dstring] defRulesToNums; // these rules must remember their numbers
}


